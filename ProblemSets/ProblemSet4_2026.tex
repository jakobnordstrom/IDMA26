\documentclass{jn-pset}
%   \documentclass[solutions]{jn-pset}

\usepackage{ifthen}
\newboolean{versionwithsolutions}
% Uncomment to insert text that should only be there in version WITH solutions
\setboolean{versionwithsolutions}{true}
% Uncomment to insert text that should only be there in version WITHOUT solutions
\setboolean{versionwithsolutions}{false}


%%%%
%%%% QUICK INSTRUCTIONS FOR FORMATTING OF PROBLEMS
%%%%
%    
% Code a problem by
%    \begin{problem}
%    \end{problem}
%
% Code a subproblem inside a problem by (note the percent signs!)
%    \begin{subproblem}%
%        \label{problem:labelhere}%
%        Text here
%    \end{subproblem}
%
% Get a small vertical space by issuing the command
%    \smallskip
%
% To give a hint to a problem (after having completed the problem statement),
% use the following LaTeX code for formatting consistency:
%
%    \smallskip
%    \noindent
%    \emph{Hint:}
%    Consider the following super-useful hint for this particular problem...
%

% PROBLEM-SET-SPECIFIC MACROS (UPDATE FOR EACH PROBLEM SET)

\newcommand{\psetno}{4}
\newcommand{\duedate}{Wednesday March 25 at 12:59 CET}

\newcommand{\thresholdforpass}{$120$~points\xspace}

% Compact lists
\usepackage{paralist}

\input{course-macros.tex}

% For getting watermark "DRAFT" across all pages (for instance, 
% when posting preliminary version of problem set)
\usepackage{draftwatermark}
% \SetWatermarkFontSize{20 cm}
\SetWatermarkScale{5}

% For METAPOST logo as \hologo{METAPOST}
%   \usepackage{hologo}

% For TikZ
%   \input{Figures/tikz-packages.tex}

%%%
%%% TITLE
%%%

\author{\courseinstructor}
\course{\coursenamelong{}}
\semester{\courseperiod}
\title{\coursenameshort: Problem Set \psetno}

\begin{document}

\maketitle

\input{IDMA_Pset_GeneralInstructions}



 
%%%
%%% IDMA EXAM 2026: PROBLEM 8
%%% GRAPH PROBLEM: SHORTEST PATH
%%%

\begin{problem}%
  \label{problem:shortest-path}%
  (90 p)
  When Jakob has international visitors, he needs to give them travel
  directions from Kastrup Airport to the
  Department of Computer Science (DIKU) at Universitetsparken.  Jakob
  is aware of the following relevant public transport options in
  Copenhagen with travel times as stated
%     (in either direction):
  (in either direction, and with time for switching transport mode included):
  \begin{compactitem}
  \item
    Between Kastrup Airport and Kongens Nytorv by metro: 13 minutes.
    
  \item
    Between Kastrup Airport and København H by train: 20 minutes.
    
  \item
    Between København H and Nørreport by train: 3 minutes.
    
  \item
    Beween København H and Kongens Nytorv by metro: 4 minutes.
    
  \item
    Between Kongens Nytorv and Vibenshus Runddel by metro: 10 minutes.

  \item
    Between Vibenshus Runddel and Universitetsparken by foot: 9 minutes.
    
  \item
    Between Nørreport and Universitetsparken by bus: 8 minutes.

  \end{compactitem}
%
  What is not so clear to Jakob is how he should use this information
  to find
%     a good route
  as fast a route as possible
  between the airport and DIKU to suggest to his
  visitors.
  
  \begin{subproblem}
    \ifthenelse{\boolean{versionwithsolutions}}
    {(20 p)}
    {\ignorespaces}
    Help Jakob by modelling this problem as a graph.
    Explain what the vertices and edges represent and what other
    information you need to add to the graph.
    Make sure to show concretely what graph you obtain
    for Jakob's problem above.
  \end{subproblem}


\begin{solution}
  We create a graph with $6$~vertices:
  \begin{compactitem}
  \item vertex 
    $A$ for Kastrup Airport, 

  \input{Figures/figPublicTransport.tex}
    
  \item vertex 
    $K$ for Kongens Nytorv,

  \item vertex 
    $H$ for København H,

  \item vertex 
    $N$ for Nørreport,

  \item vertex 
    $V$ for Vibenshus Runddel,

  \item vertex 
    $U$ for Universitetsparken and DIKU.

  \end{compactitem}
%  
  Between these vertices we add edges as specified by the travel options 
%     in the problem statement
  with weights equal to the travel
  times, and these edges are undirected since 
%     it is clearly stated that
  the time given is for  travel in either direction:
%     This yields the  following edges:
  \begin{compactitem}
  \item edge 
    $(A, K)$ with weight~$13$,
    
  \item edge 
    $(A, H)$ with weight~$20$,
    
  \item edge 
    $(H, N)$ with weight~$3$,
    
  \item edge 
    $(H, K)$ with weight~$4$,

  \item edge 
    $(K, V)$ with weight~$10$,

  \item edge 
    $(V, U)$ with weight~$9$,

  \item edge 
    $(N, U)$ with weight~$8$.
  \end{compactitem}
%
  This yields the graph in
  \reffig{fig:public-transport-graph}.
  
\end{solution}


\begin{subproblem}
  \ifthenelse{\boolean{versionwithsolutions}}
    {(70 p)}
    {\ignorespaces}
    Propose a suitable graph algorithm to solve Jakob's problem.
    Explain what this algorithm is and why it is the right choice for
    this problem.  Make a dry-run of the algorithm and explain the
    relevant steps in the execution (similarly to what has been done
    in class and in the lecture notes).
    
    If your algorithm uses any auxiliary data structures, then explain in detail
    for the first two vertices processed how these data structures
    change. For the rest of the algorithm execution, just
    report what the relevant outputs of the data structures are without
    going into any details.

    What travel directions for Jakob's visitors does your algorithm produce?    
  \end{subproblem}
  

\begin{solution}
  What Jakob is looking for is the fastest route from Kastrup to DIKU,
  i.e., the shortest path in a graph where the edge weights are the
  travel times between different locations.
  We have learned in the course to compute such shortest paths by
  using Dijkstra's algorithm.

  \input{Figures/figHeapsPublicTransport.tex}

%     
%     We therefore run Dijkstra's algorithm on the graph in
%     \reffig{fig:public-transport-graph}.
%     The version of Dijkstra's algorithm that we have learned uses a
%     priority queue implemented with the help of a min-heap.
%   
  Following the instructions in the problem statement,
  when running Dijkstra's algorithm 
%     on the graph in
%     \reffig{fig:public-transport-graph}
  we illustrate in
  \reffig{fig:heaps-public-transport}
  how the heap used for the priority queue changes during 
%     the  execution of the algorithm.
  algorithm execution,
  using the
%     We use the 
  notation $v:k$
%     in the heap when vertex $v$ has key value~$k$.
  for a vertex $v$ with key value~$k$.
  At the outset, the vertex $A$
  corresponding to Kastrup Airport
  has key~$0$ and all other
  vertices have key~$\infty$ as in \reffig{fig:heaps-public-transport-1}.

  \begin{enumerate}
  \item 
    After vertex $A$ has been dequeued, vertex~$V$ is moved to the top of the heap
    and we have the configuration in
    \reffig{fig:heaps-public-transport-2}.
    Relaxing the edge $(A, H)$ gives value $20$ to~$H$ (\ie the weight
    of the edge), and 
    % so shifts $H$ to the top and pushes~$V$ down below it,
    and the min-heap property is restored by letting $H$ bubble up above~$V$, 
    yielding
    \reffig{fig:heaps-public-transport-3}.
    Relaxing~$(A, K)$
    decreases the key of~$K$ to~$13$ and
    makes $H$ bubble up above~$K$, yielding
    \reffig{fig:heaps-public-transport-4}.
%%
    These are all edges incident to~$A$ that we need to consider for
    relax operations.
    
  \item 
    Since vertex $K$ is at the top of the heap, it is dequeued
    next. This adds the edge~$(A,K)$ to the spanning tree,
    which we indicate in
    \reffig{fig:public-transport-spanning-tree}.
    When $K$ is removed, $U$~is moved to the top. This violates the
    min-heap property, since the key of~$U$ 
    is not smaller than or equal to those of its
    children.  Since $H$~has smaller key than~$V$, we swap $U$
    and~$H$. This restores the heap property
    (since the left subtree of the root was not changed, and~$U$~is
    now the root of a singleton subheap), and so the
    heap after removal of~$K$
    looks as in 
    \reffig{fig:heaps-public-transport-5}.    

    \input{Figures/figPublicTransportSpanningTree.tex}
        
    Relaxing the edge~$(K, H)$ decreases the key value of~$H$ to~$17$.
    Since~$H$~is already the root, the heap does not
    change except for this key update and now looks like in
    \reffig{fig:heaps-public-transport-6}.    
%%
    Relaxing~$(K, V)$  decreases the key value of~$V$ to~$23$,
    but again does not lead to any structural changes in the heap
    since $V$ still has a larger key than its parent~$H$
    (see \reffig{fig:heaps-public-transport-7}).
    There are no further edges incident to~$K$ to relax.
%% 
    According to the instructions in the problem statement, we do not
    need to provide any further heap illustrations from this point on.
    

  \item
    Since $H$ is now the vertex with the smallest key value it is dequeued next,
    and the edge~$(K, H)$ is added to the spanning tree
    (since the latest update of the key value of~$H$ was when relaxing
    the edge~$(K, H)$).
%%
    When the edge $(H, N)$ is relaxed the key of~$N$ is updated to~$20$.

  \item
    Vertex~$N$ currently has the smallest key~$20$ and is dequeued next.
    This adds the edge~$(H, N)$ to the spanning paths tree, since
    the key of~$N$ was last updated when $(H, N)$ was relaxed.
    Relaxing~$(N,U)$
    updates the key of~$U$ to~$28$.

  \item
    Now vertex~$V$ has the smallest key~$23$ and so is dequeued,
    adding~$(K, V)$ to the spanning tree.
    When we relax~$(V,U)$
    nothing happens since $23 + 9 \geq 28$.

  \item
    Finally, vertex~$U$ is dequeued,
    adding the edge~$(N, U)$
    to the spanning tree. The queue is now empty, and there is nothing
    to relax.
  \end{enumerate}
%   
  The shortest path spanning tree computed as described above is indicated
  by the bold edges in 
  \reffig{fig:public-transport-spanning-tree}.
  From this tree we can read off that the fastest route for Jakob's
  guests is
  Kastrup Airport
  --
  Kongens Nytorv
  --
  København H
  --
  Nørreport
  --
  Universitetsparken/DIKU.
\end{solution}

\end{problem}



%%%
%%% IDMA EXAM 2026: PROBLEM 9
%%% GRAPH PROBLEM: IDENTIFY OUTPUT OF DIFFERENT ALGORITHMS
%%%
%   Give 10 points per correct answer.
%   Give 20 extra points for a overview of how and why the algorithms process the vertices in this order.
%   

\begin{problem}%
  \label{problem:graph-algorithm-outputs}%
  (120 p)
  Consider the graph in   
  \reffig{fig:graph-algorithm-outputs}
  and the following ordered sequences listing the vertices in this graph:
%%%  
%%% Random permutation: 3, 1, 4, 2
%%%  
  \begin{compactenum}
    % 3. Dijkstra from a
  \item%
    \label{sequence-dijkstra}%    
    $a$, $c$, $e$, $b$, $h$, $g$, $f$, $d$.

%       \input{Figures/figGraphAlgorithmOutputs-25.tex}    
        
    % 1. BFS from a
  \item%
    \label{sequence-bfs}%    
    $a$, $b$, $c$, $e$, $d$, $h$, $g$, $f$.

    % 4. Spoiler        
  \item%
    \label{sequence-spoiler}%    
    $a$, $c$, $b$, $e$, $h$, $g$, $f$, $d$.
        
    % 2. DFS from a
  \item%
    \label{sequence-dfs}%
    $a$, $b$, $d$, $c$, $e$, $h$, $g$, $f$.
    
  \end{compactenum}
  %
  For each of the sequences above, determine whether it can be the result of:
  \begin{compactenum}[(a)]
  \item
    a breadth-first search with vertices listed in order of visits;
    
  \item
    a depth-first search with vertices listed in order of discovery;
    
  \item
    a shortest-path computation with vertices listed in the order they
    are removed from the priority queue.

  \end{compactenum}
%
  Each sequence above is the output of at most one of the algorithms,
  but since there are four sequences there could be a sequence that
  cannot be produced by any of the algorithms.

  Partial credit is given for matching algorithms and vertex sequences correctly.
%
  For full credit, you need to
  give an overview of how and why the
  algorithms process the vertices in the given order
  (such as explaining the order of recursive calls, edges processed,
  or similar),
  or why none of the proposed algorithms could yield the sequence in
  question,  
  but you do not have to provide detailed information about any
  auxiliary data structures used in the algorithms.

\begin{solution}
  Let us consider the different algorithms in the order listed and
  try to find sequences that would match their outputs.
  Since we are promised that each sequence is the output of at most
  one algorithm, we are done with each sequence as soon as we find a
  match.
  
  \textit{\textbf{Sequence~\ref{sequence-bfs}}}
  is the result of breadth-first search starting with vertex~$a$.
  To see this, consider how the different vertices are enqueued in and
  dequeued from the queue if we start the breadth-first search in
  vertex~$a$:

  \medskip
  \noindent
  \begin{tabular}[]{|l|l|l|}
    \hline
    \textbf{Dequeued vertex}
    &
      \textbf{Enqueued vertices}
    &
      \textbf{Queue}
    \\
    \hline
    ---
    &
      ---
    &
      $(a)$
    \\
    $a$
    &
      $\set{b, c, e}$
    &
      $(b, c, e)$
      \\
    $b$
    &
      $\set{d}$
    &
      $(c, e, d)$
    \\
    $c$
    &
      ---
    &
      $(e, d)$
    \\
    $e$
    &
      $\set{h}$
    &
      $(d, h)$
    \\
    $d$
    &
      ---
    &
      $(h)$
    \\
    $h$
    &
      $\set{g}$
    &
      $(g)$
    \\
    $g$
    &
      $\set{f}$
    &
      $(f)$
    \\
    $f$
    &
      ---
    &
      $()$
    \\
    \hline
  \end{tabular}

  \bigskip

  
  \textit{\textbf{Sequence~\ref{sequence-dfs}}}
  is the result of depth-first
  search starting with vertex~$a$.
  Below follows an illustration of in which orders vertices are
  discovered and finished: \\
  \vspace{-6.0mm}
  \begin{tabbing}
    Disco\={}ver  $a$ --- undiscovered neighbours $b$, $c$ and~$e$
    \\
    \> Disco\={}ver  $b$ --- undiscovered neighbour $d$
    \\
    \> \> Disco\={}ver  $d$  --- undiscovered neighbour $c$
    \\
    \> \> \> Disco\={}ver  $c$ --- no undiscovered neighbours
    \\
    \> \> \> Finish $c$, since no undiscovered neighbours
    \\
    \> \> Finish $d$, since no undiscovered neighbours left
    \\
    \> Finish $b$, since no undiscovered neighbours left
    \\
    \> Discover $e$ --- undiscovered neighbour $h$
    \\
    \> \> Discover $h$  --- undiscovered neighbour $g$
    \\
    \> \> \> Discover $g$  --- undiscovered neighbour $f$
    \\
    \> \> \> \> Discover $f$ --- no undiscovered neighbours
    \\
    \> \> \> \> Finish $f$, since no undiscovered neighbours 
    \\
    \> \> \> Finish $g$, since no undiscovered neighbours left
    \\
    \> \> Finish $h$, since no undiscovered neighbours left
    \\
    \> Finish $e$, since no undiscovered neighbours left
    \\
    Finish $a$, since no undiscovered neighbours left
  \end{tabbing}
  
  
  \textit{\textbf{Sequence~\ref{sequence-dijkstra}}}
  is the result of a call to Dijkstra's algorithm computing shortest
  paths from vertex~$a$.
  To see this, consider in which order the vertices are dequeued from
  the priority queue and how vertex key values are updated as edges
  are relaxed:

  \medskip
  \noindent
  \begin{tabular}[]{|l|l|l|}
    \hline
    \textbf{Dequeued}
    &
%         \textbf{Vertex updates}
      \textbf{Updates}
    &
      \textbf{Priority queue (after relaxations)}
    \\
    \hline
    ---
    &
      ---
    &
      $
      \set{
      (a: 0),
      (b: \infty),
      (c: \infty),
      (d: \infty),
      (e: \infty),
      (f: \infty),
      (g: \infty),
      (h: \infty)
      }
      $
    \\
    $a$
    &
      $\set{b, c, e}$
    &
      $
      \set{
      (c: 2),
      (e: 4),
      (b: 6),
      (d: \infty),
      (f: \infty),
      (g: \infty),
      (h: \infty)
      }
      $
    \\
    $c$
    &
      $\set{b}$
    &
      $
      \set{
      (e: 4),
      (b: 5),
      (d: \infty),
      (f: \infty),
      (g: \infty),
      (h: \infty)
      }
      $
    \\
    $e$
    &
      $\set{h}$
    &
      $
      \set{
      (b: 5),
      (h: 6),      
      (d: \infty),
      (f: \infty),
      (g: \infty)
      }
      $
    \\
    $b$
    &
      $\set{d}$
    &
      $
      \set{
      (h: 6),      
      (d: 12),
      (f: \infty),
      (g: \infty)
      }
      $
    \\
    $h$
    &
      $\set{g}$
    &
      $
      \set{
      (g: 7),      
      (d: 12),
      (f: \infty)
      }
      $
    \\
    $g$
    &
      $\set{f}$
    &
      $
      \set{
      (f: 9),      
      (d: 12)
      }
      $
    \\
    $f$
    &
      $\set{d}$
    &
      $
      \set{
      (d: 10)
      }
      $
    \\
    $d$
    &
      ---
    &
      $
      \set{
      }
      $
    \\
    \hline
  \end{tabular}

  \bigskip
  
  \textit{\textbf{Sequence~\ref{sequence-spoiler}}}, finally,
  is a spoiler sequence that cannot be the output of any of the
  algorithms listed. To see this, consider the following case
  analysis:
  \begin{compactitem}
  \item
    If the sequence were the result of breadth-first search,
    then it would list vertices in order of the number of directed
    edges required to get to the vertex     from
    the start vertex~$a$, but the first deviation from this is that
    $g$ is listed before~$d$.
    
  \item
    A depth-first search starting with $a$, $c$, $b$ would discover~$d$
    next and not~$e$.
        
  \item
    Finally, the sequence cannot be the output of Dijkstra's    algorithms,
    since the vertices are not listed in increasing order of distance
    from~$a$. The first deviation here is that $e$ should come
    before~$b$ in a listing in increasing order of distance.
    
  \end{compactitem}

  
\end{solution}

  \input{Figures/figGraphAlgorithmOutputs-25.tex}    

  
\end{problem}


\end{document}


